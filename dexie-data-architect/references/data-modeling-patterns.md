# Data Modeling Patterns for Dexie.js

Effective data modeling is foundational for building robust and scalable applications with Dexie.js. This document explores common patterns for structuring your data, managing relationships, and planning for schema evolution.

## 1. Modeling Relationships

IndexedDB, and by extension Dexie.js, does not natively support relational joins like traditional SQL databases. Relationships are typically managed by storing foreign keys and performing in-memory joins.

### a. One-to-Many Relationships

**Example**: One `Account` has many `Transactions`. One `Category` has many `Transactions`.

**Pattern**: Store the primary key of the "one" side as a foreign key in the "many" side.

**Schema Example:**
```javascript
db.version(1).stores({
    accounts: '++id, name',
    categories: '++id, name',
    transactions: '++id, date, amount, accountId, categoryId' // accountId and categoryId are foreign keys
});
```

**Accessing Related Data (Enrichment)**:
You'll typically fetch the "many" items and then, for each item, fetch its related "one" item(s). Custom hooks (like those generated by `generate-enrichment-hook.cjs`) are ideal for this.

```javascript
// Example of fetching transactions and their related account/category (conceptual)
const transactions = await db.transactions.toArray();
const enrichedTransactions = await Promise.all(transactions.map(async tx => {
    tx.account = await db.accounts.get(tx.accountId);
    tx.category = await db.categories.get(tx.categoryId);
    return tx;
}));
```
*Tip: Ensure foreign key fields (`accountId`, `categoryId`) are indexed for efficient lookups.*

### b. Many-to-Many Relationships

**Example**: A `Transaction` could be associated with multiple `Tags`, and a `Tag` can be associated with multiple `Transactions`.

**Pattern**: Use an intermediary "join table" (or "link table") that stores the primary keys of both entities.

**Schema Example:**
```javascript
db.version(1).stores({
    transactions: '++id, date, amount',
    tags: '++id, name',
    transactionTags: '++id, transactionId, tagId, [transactionId+tagId]' // Join table
});
```

**Accessing Related Data**:
*   To get all `Tags` for a `Transaction`: Query `transactionTags` by `transactionId`, then fetch `Tags` by `tagId`.
*   To get all `Transactions` for a `Tag`: Query `transactionTags` by `tagId`, then fetch `Transactions` by `transactionId`.

## 2. Embedded vs. Normalized Data

This decision impacts query complexity, storage, and update efficiency.

### a. Normalized Data (Recommended for most cases)

**Pattern**: Data is split into multiple tables, with relationships defined by foreign keys.
**Pros**:
*   Reduces data redundancy.
*   Ensures data consistency (e.g., updating a category name only happens in one place).
*   Smaller storage footprint for redundant data.
**Cons**:
*   Requires performing in-memory joins to reconstruct full objects.

**When to Use**: Almost always, especially for data that changes frequently or requires strong consistency. The budget management app largely uses this pattern (transactions, accounts, categories are separate).

### b. Embedded Data

**Pattern**: Related data is stored directly within the main record.
**Example**: Embedding a `categoryName` directly into the `transaction` record.

**Schema Example (Conceptual - not recommended for categories):**
```javascript
db.version(1).stores({
    transactions: '++id, date, amount, accountId, categoryId, categoryName' // categoryName embedded
});
```
**Pros**:
*   Faster reads for the embedded data (no join needed).
*   Simpler queries if only the embedded data is needed.
**Cons**:
*   Data redundancy (category name is duplicated across many transactions).
*   Update anomalies (if category name changes, all transactions must be updated).
*   Increased storage size if embedded data is large.

**When to Use**: For immutable or rarely changing, small pieces of data that are *always* needed with the parent object, and where data redundancy is acceptable. For example, if a `transaction` had a simple, fixed `currencySymbol` that never changes, embedding it might be considered. **Avoid embedding for mutable lookup values like category names in a budget app.**

## 3. Schema Evolution and Versioning

Dexie.js provides a robust mechanism for schema evolution using `db.version(versionNumber).stores(...)` and `upgrade(transaction => { ... })`.

**Pattern**: Increment the database version number and define the new schema for each new version. Use the `upgrade` callback to handle data migration.

**Example:**
```javascript
// Initial Schema (Version 1)
db.version(1).stores({
    transactions: '++id, date, amount, accountId'
});

// Evolving Schema (Version 2 - add categoryId)
db.version(2).stores({
    transactions: '++id, date, amount, accountId, categoryId', // New schema for transactions
    categories: '++id, name'
}).upgrade(async (trans) => {
    // Data migration logic for version 2
    // Add a default categoryId to existing transactions
    const defaultCategory = await trans.categories.add({ name: 'Uncategorized' });
    await trans.transactions.toCollection().modify(transaction => {
        transaction.categoryId = defaultCategory;
    });
});
```
*Tip: The `generate-migration-script.cjs` can help scaffold this boilerplate.*

## 4. Other Patterns

*   **Audit Trails**: For tracking changes, create a separate `auditLog` table that stores who, what, when, and where a change occurred. Use Dexie.js hooks (`db.table('yourTable').hook('creating').last(...)`) to automatically log changes.
*   **Settings/Preferences**: Use a single table (e.g., `settings`) with a single record to store user preferences or application settings. Access it via `db.settings.get(1)`.
*   **Large Objects (Blobs/Files)**: For very large binary data (images, documents), consider storing them outside IndexedDB (e.g., server, cloud storage) and only storing references (URLs) in Dexie.js. If stored locally, ensure proper indexing and lazy loading to avoid performance issues.

By applying these data modeling patterns, you can build efficient, maintainable, and adaptable local-first applications with Dexie.js.
